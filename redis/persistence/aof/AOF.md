# 介绍
1. AOF（Append Only File）持久化，以独立日志的方式记录每次写命令不记录读命令，重启时再重新执行AOF文件中的命令来恢复数据。
2. 需要在配置文件中打开appendonly yes

# 配置
1. 打开appendonly yes
2. aof文件和rdb文件使用同一个dir
3. redis6.12之前只有一个aof文件，之后aof有三个文件
   - base.aof: 基本文件(只有一个)
   - inr.aof: 增量文件(可能有多个)
   - manifest: 清单文件(只有一个)

# 写入策略
> 每次写入的时候会有一个buffer区域，每次将buffer区域的内容写入到aof文件中
1. always: 每次写操作都同步到aof文件，最安全，但是性能最差
2. everysec: 每秒写一次，性能和安全折中
3. no: 由操作系统决定何时同步到aof文件，性能最好，但是最不安全

# 恢复
1. 每次进行增量变更的是inr.aof文件
2. 如果aof异常，使用命令`redis-check-aof --fix <filename>`就完成对inr.aof文件的修复

# AOF重写机制
- 简介: 随着set的越来越多，aof文件越来越大，为了解决这个问题，redis提供了AOF重写机制，将aof文件进行压缩，只保留最终的数据状态。
## 配置
- auto-aof-rewrite-percentage 100
- auto-aof-rewrite-min-size 64mb
- 只有都被满足的时候会启动重写(判断文件大小是不是涨了一倍，并且文件超过64mb)
- 同时将`aof-use-rdb-preambl`从yes更改为no(关闭混合)

## 效果
- 在1.base.aof文件最开始为0，1.incr.aof文件不断增加到重写条件的时候，1.base.aof文件更改为2.base.aof文件，并且文件大小为瘦身后的大小，2.incr.aof文件大小为0.
- 也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。

## 重写原理
1. 在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文
件中。 
2. 与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可
用性，避免在重写过程中出现意外。 
3. 当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中 
4. 追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中 
5. 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似